# AoC2022/01

```elixir
Mix.install([
  {:memoize, "~> 1.4"},
  {:tesla, "~> 1.4"}
])

defmodule Api do
  use Tesla
  use Memoize

  @session System.fetch_env!("AOC_SESSION_COOKIE")

  plug(Tesla.Middleware.BaseUrl, "https://adventofcode.com/2022/day/")

  plug(Tesla.Middleware.Headers, [
    {"cookie", "session=#{@session}"}
  ])

  defmemo get_input(day) do
    {:ok, response} = get("#{day}/input")
    response.body
  end
end
```

## Day 1

```elixir
calories_per_elf =
  Api.get_input(1)
  |> String.split("\n\n")
  |> Enum.map(fn inventory ->
    inventory
    |> String.split("\n", trim: true)
    |> Enum.map(fn item ->
      String.to_integer(item)
    end)
    |> Enum.sum()
  end)

p1 = calories_per_elf |> Enum.max()

p2 = calories_per_elf |> Enum.sort(:desc) |> Enum.take(3) |> Enum.sum()

{p1, p2}
```

## Day 2

```elixir
require Integer

# Replace rock(A|X), paper(B|Y) and scissors(C|Z) with corresponding points
# rock = 1, paper = 2, scissors = 3
processed_input =
  Api.get_input(2)
  |> String.split("\n", trim: true)
  |> Enum.map(fn fight ->
    String.replace(fight, ~r/(A|X)/, "1")
    |> String.replace(~r/(B|Y)/, "2")
    |> String.replace(~r/(C|Z)/, "3")
    |> String.split(" ", trim: true)
    |> Enum.map(fn x -> String.to_integer(x) end)
  end)

p1 =
  processed_input
  |> Enum.map(fn [x, y] ->
    v = x - y
    isEven = Integer.is_even(v)

    case v do
      0 -> y + 3
      v when v > 0 -> if isEven, do: y + 6, else: y
      v when v < 0 -> if !isEven, do: y + 6, else: y
    end
  end)
  |> Enum.sum()

# [rock, paper, scissors]
status = [1, 2, 3]

# Next element loses with the previous one:
# rock < paper < scissors < rock
#   1  <   2   <    3     <   1
p2 =
  processed_input
  |> Enum.map(fn [x, y] ->
    case y do
      1 -> Enum.at(status, rem(x + 1, 3))
      2 -> x + 3
      3 -> Enum.at(status, rem(x, 3)) + 6
    end
  end)
  |> Enum.sum()

{p1, p2}
```
